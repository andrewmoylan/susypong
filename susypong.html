<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Susy Pong</title>
    <style>
        body { margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background-color: #f0f0f0; }
        canvas { border: 1px solid black; background-color: #fff; }
    </style>
</head>
<body>
    <canvas id="pongCanvas"></canvas>

    <script>
        const canvas = document.getElementById('pongCanvas');
        const context = canvas.getContext('2d');

        // Game dimensions
        canvas.width = 600;
        canvas.height = 400;

        // Paddle
        const paddleWidth = 100;
        const paddleHeight = 10;
        let paddleX = (canvas.width - paddleWidth) / 2;
        const paddleY = canvas.height - paddleHeight - 10; // 10px from bottom

        // Ball
        const heartSize = 10; // General size for hearts, used for drawing and collision
        let balls = []; // Array to hold multiple ball objects

        // Game state
        // let gameOver = false; // Removed: game no longer ends
        let score = 0;

        document.addEventListener('mousemove', movePaddle);

        function movePaddle(event) {
            const rect = canvas.getBoundingClientRect();
            paddleX = event.clientX - rect.left - paddleWidth / 2;

            // Keep paddle within canvas bounds
            if (paddleX < 0) {
                paddleX = 0;
            }
            if (paddleX + paddleWidth > canvas.width) {
                paddleX = canvas.width - paddleWidth;
            }
        }

        function drawPaddle() {
            context.fillStyle = 'blue';
            context.fillRect(paddleX, paddleY, paddleWidth, paddleHeight);
        }

        // Draw a heart shape centered at ball.x, ball.y
        function drawHeartShape(ball) {
            const cx = ball.x;
            const cy = ball.y;
            const size = heartSize; // Use heartSize as the basis for width/height
            
            // Define heart dimensions based on 'size'
            // Heart width will be 'size * 2', height 'size * 1.8'
            // This means 'size' acts like a half-width for the heart.
            const width = size * 2;
            const height = size * 1.8;

            context.fillStyle = ball.color || 'pink'; // Use ball's color or default to pink

            context.save(); // Save current context state (like fillStyle, transformations)
            context.translate(cx, cy); // Move canvas origin to the heart's center point

            context.beginPath();
            // Path is drawn relative to the new (cx,cy) origin.
            // Start at the bottom tip of the heart.
            context.moveTo(0, height / 2);
            // Left side curves (Bezier curve to the start of the left lobe arc)
            context.bezierCurveTo(-width / 20, height / 2.5, -width / 2, -height / 8, -width / 2, -height / 3.5);
            // Left lobe (an arc)
            context.arc(-width / 4, -height / 3.5, width / 4, Math.PI, 0, false);
            // Right lobe (an arc)
            context.arc(width / 4, -height / 3.5, width / 4, Math.PI, 0, false);
            // Right side curves (Bezier curve from the end of the right lobe arc to the bottom tip)
            context.bezierCurveTo(width / 2, -height / 8, width / 20, height / 2.5, 0, height / 2);
            
            context.fill();
            context.closePath();
            context.restore(); // Restore canvas context to its state before save()
        }

        function drawScore() {
            context.font = '16px Arial';
            context.fillStyle = 'black';
            context.fillText('Score: ' + score, 8, 20);
        }
        
        function resetBalls() {
            balls = []; // Clear existing balls
            balls.push({
                x: canvas.width / 3, // Start first ball on left side
                y: canvas.height / 3,
                speedX: 3,
                speedY: -3,
                color: 'hotpink' // First heart color
            });
            balls.push({
                x: (canvas.width * 2) / 3, // Start second ball on right side
                y: canvas.height / 3,
                speedX: -3,
                speedY: -2.5, // Slightly different speed for variety
                color: 'deeppink' // Second heart color
            });
        }

        function update() {
            // if (gameOver) { // Removed: game no longer ends, this block is gone
                context.font = '30px Arial';
                context.fillStyle = 'black';
                context.textAlign = 'center';
                context.fillText('Game Over! Score: ' + score, canvas.width / 2, canvas.height / 2);
                context.font = '16px Arial';
                context.fillText('Click to Restart', canvas.width / 2, canvas.height / 2 + 30);
                return;
            }

            // Move ball
            ballX += ballSpeedX;
            ballY += ballSpeedY;

            // Wall collision (left/right)
            if (ballX + ballRadius > canvas.width || ballX - ballRadius < 0) {
                ballSpeedX = -ballSpeedX;
            }

            // Wall collision (top)
            if (ballY - ballRadius < 0) {
                ballSpeedY = -ballSpeedY;
            }

            // Paddle collision
            if (ballY + ballRadius > paddleY && 
                ballY - ballRadius < paddleY + paddleHeight &&
                ballX + ballRadius > paddleX && 
                ballX - ballRadius < paddleX + paddleWidth) {
                ballSpeedY = -ballSpeedY;
                // Optional: Add slight angle change based on where it hits the paddle
                let deltaX = ballX - (paddleX + paddleWidth / 2);
                ballSpeedX = deltaX * 0.2; // Adjust this factor for more/less effect
                score++;
            }

            // Ball misses paddle (bottom wall)
            if (ballY + ballRadius > canvas.height) {
                gameOver = true;
            }
        }

        function draw() {
            // Clear canvas
            context.clearRect(0, 0, canvas.width, canvas.height);

            if (gameOver) {
                update(); // To display game over message
                return;
            }

            drawPaddle();
            drawBall();
            drawScore();
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // canvas.addEventListener('click', ...); // Removed: Game no longer has a 'game over' state,
                                                 // so click-to-restart is not needed.

        resetBalls(); // Initialize balls' positions and speeds
        gameLoop();
    </script>
</body>
</html>
